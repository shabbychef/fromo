% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{running_sd3}
\alias{running_cent_moments}
\alias{running_kurt5}
\alias{running_sd3}
\alias{running_skew4}
\alias{running_std_moments}
\title{Compute first K moments over a sliding window}
\usage{
running_sd3(v, window = NULL, na_rm = FALSE, min_df = 0L, used_df = 1L,
  restart_period = 100L)

running_skew4(v, window = NULL, na_rm = FALSE, min_df = 0L,
  used_df = 1L, restart_period = 100L)

running_kurt5(v, window = NULL, na_rm = FALSE, min_df = 0L,
  used_df = 1L, restart_period = 100L)

running_cent_moments(v, window = NULL, max_order = 5L, na_rm = FALSE,
  min_df = 0L, used_df = 0L, restart_period = 100L)

running_std_moments(v, window = NULL, max_order = 5L, na_rm = FALSE,
  min_df = 0L, used_df = 0L, restart_period = 100L)
}
\arguments{
\item{v}{a vector}

\item{window}{the window size. if given as finite integer or double, passed through.
If \code{NULL}, \code{NA_integer_}, \code{NA_real_} or \code{Inf} are given, equivalent
to an infinite window size. If negative, an error will be thrown.}

\item{na_rm}{whether to remove NA, false by default.}

\item{min_df}{the minimum df to return a value, otherwise \code{NaN} is returned.
This can be used to prevent moments from being computed on too few observations.
Defaults to zero, meaning no restriction.}

\item{used_df}{the number of degrees of freedom consumed, used in the denominator
of the centered moments computation. These are subtracted from the number of
observations.}

\item{restart_period}{the recompute period. because subtraction of elements can cause
loss of precision, the computation of moments is restarted periodically based on 
this parameter. Larger values mean fewer restarts and faster, though less accurate
results. Note that the code checks for negative second and fourth moments and
recomputes when needed.}

\item{max_order}{the maximum order of the centered moment to be computed.}
}
\value{
a matrix; the first columns are the kth, k-1th through 2nd standardized, centered moment,
then a column of the mean, then a column of the number of (non-nan) elements in the input.
When there are not sufficient (non-nan) elements for the computation, \code{NaN} are returned.
}
\description{
Compute the (standardized) 2nd through kth moments, the mean, and the number of elements over
an infinite or finite sliding window, returning a matrix.
}
\details{
Computes the number of elements, the mean, and the 2nd through kth
centered standardized moment, for \eqn{k=2,3,4}{k=2,3,4}. These
are computed via the numerically robust one-pass method of Bennett \emph{et. al.}

Given the length \eqn{n} vector \eqn{x}, we output matrix \eqn{M} where
\eqn{M_{i,j}}{M_i,j} is the \eqn{order - j + 1} moment (\emph{i.e.}
excess kurtosis, skewness, standard deviation, mean or number of elements)
of \eqn{x_{i-window+1},x_{i-window+2},...,x_{i}}{x_(i-window+1),x_(i-window+2),...,x_i}.
Barring \code{NA} or \code{NaN}, this is over a window of size \code{window}.
During the 'burn-in' phase, we take fewer elements.
}
\note{
the kurtosis is \emph{excess kurtosis}, with a 3 subtracted, and should be nearly zero
for Gaussian input.

The moment computations provided by fromo are 
numerically robust, but will often \emph{not} provide the
same results as the 'standard' implementations,
due to differences in roundoff. We make every attempt to balance
speed and robustness. User assumes all risk from using
the fromo package.
}
\examples{
x <- rnorm(1e5)
xs3 <- running_sd3(x,10)
xs4 <- running_skew4(x,10)

if (require(moments)) {
    set.seed(123)
    x <- rnorm(5e1)
    window <- 10L
    kt5 <- running_kurt5(x,window=window)
    rm1 <- t(sapply(seq_len(length(x)),function(iii) { 
                xrang <- x[max(1,iii-window+1):iii]
                c(moments::kurtosis(xrang)-3.0,moments::skewness(xrang),
                sd(xrang),mean(xrang),length(xrang)) },
             simplify=TRUE))
    stopifnot(max(abs(kt5 - rm1),na.rm=TRUE) < 1e-12)
}

xc6 <- running_cent_moments(x,window=100L,max_order=6L)

}
\author{
Steven E. Pav \email{shabbychef@gmail.com}
}
\references{
Terriberry, T. "Computing Higher-Order Moments Online."
\url{http://people.xiph.org/~tterribe/notes/homs.html}

J. Bennett, et. al., "Numerically Stable, Single-Pass, 
Parallel Statistics Algorithms," Proceedings of IEEE
International Conference on Cluster Computing, 2009.
\url{https://www.semanticscholar.org/paper/Numerically-stable-single-pass-parallel-statistics-Bennett-Grout/a83ed72a5ba86622d5eb6395299b46d51c901265}

Cook, J. D. "Accurately computing running variance."
\url{http://www.johndcook.com/standard_deviation.html}

Cook, J. D. "Comparing three methods of computing 
standard deviation."
\url{http://www.johndcook.com/blog/2008/09/26/comparing-three-methods-of-computing-standard-deviation}
}

