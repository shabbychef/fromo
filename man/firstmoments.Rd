% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{sd3}
\alias{cent_moments}
\alias{kurt5}
\alias{sd3}
\alias{skew4}
\title{Compute first K moments}
\usage{
sd3(v, na_rm = FALSE)

skew4(v, na_rm = FALSE)

kurt5(v, na_rm = FALSE)

cent_moments(v, max_order = 5L, used_df = 0L, na_rm = FALSE)
}
\arguments{
\item{v}{a vector}

\item{na_rm}{whether to remove NA, false by default.}

\item{max_order}{the maximum order of the centered moment to be computed.}

\item{used_df}{the number of degrees of freedom consumed, used in the denominator
of the centered moments computation. These are subtracted from the number of
observations.}
}
\value{
a vector; the first elements are the kth, k-1th through 2nd standardized, centered moment,
then the mean, then the number of (non-nan) elements in the input.
}
\description{
Compute the (standardized) 2nd through kth moments, the mean, and the number of elements.
}
\details{
Computes the number of elements, the mean, and the 2nd through kth
centered standardized moment, for \eqn{k=2,3,4}{k=2,3,4}. These
are computed via the numerically robust one-pass method of Bennett \emph{et. al.}
In general they will \emph{not} match exactly with the 'standard'
implementations, due to differences in roundoff.

These methods are reasonably fast, on par with the 'standard' implementations.
However, they will usually be faster than calling the various standard implementations
more than once.
}
\note{
the kurtosis is \emph{excess kurtosis}, with a 3 subtracted, and should be nearly zero
for Gaussian input.

The moment computations provided by fromo are 
numerically robust, but will often \emph{not} provide the
same results as the 'standard' implementations,
due to differences in roundoff. We make every attempt to balance
speed and robustness. User assumes all risk from using
the fromo package.
}
\examples{
x <- rnorm(1e5)
sd3(x)[1] - sd(x)
skew4(x)[4] - length(x)
skew4(x)[3] - mean(x)
skew4(x)[2] - sd(x)
if (require(moments)) {
  skew4(x)[1] - skewness(x)
}
# check 'robustness'; only the mean should change:
kurt5(x + 1e12) - kurt5(x)
# check speed
if (require(microbenchmark) && require(moments)) {
  dumbk <- function(x) { c(kurtosis(x) - 3.0,skewness(x),sd(x),mean(x),length(x)) }
  set.seed(1234)
  x <- rnorm(1e6)
  print(kurt5(x) - dumbk(x))
  microbenchmark(dumbk(x),kurt5(x),times=10L)
}

}
\author{
Steven E. Pav \email{shabbychef@gmail.com}
}
\references{
Terriberry, T. "Computing Higher-Order Moments Online."
\url{http://people.xiph.org/~tterribe/notes/homs.html}

J. Bennett, et. al., "Numerically Stable, Single-Pass, 
Parallel Statistics Algorithms," Proceedings of IEEE
International Conference on Cluster Computing, 2009.
\url{https://www.semanticscholar.org/paper/Numerically-stable-single-pass-parallel-statistics-Bennett-Grout/a83ed72a5ba86622d5eb6395299b46d51c901265}

Cook, J. D. "Accurately computing running variance."
\url{http://www.johndcook.com/standard_deviation.html}

Cook, J. D. "Comparing three methods of computing 
standard deviation."
\url{http://www.johndcook.com/blog/2008/09/26/comparing-three-methods-of-computing-standard-deviation}
}

