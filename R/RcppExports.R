# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title
#' Compute first K moments
#' @description
#' Compute the (standardized) 2nd through kth moments, the mean, and the number of elements.
#' 
#' @param v a vector
#' @param na_rm whether to remove NA, false by default.
#' @param used_df the number of degrees of freedom consumed, used in the denominator
#' of the centered moments computation. These are subtracted from the number of
#' observations.
#' @param max_order the maximum order of the centered moment to be computed.
#'
#' @details
#'
#' Computes the number of elements, the mean, and the 2nd through kth
#' centered standardized moment, for \eqn{k=2,3,4}{k=2,3,4}. These
#' are computed via the numerically robust one-pass method of Bennett \emph{et. al.}
#' In general they will \emph{not} match exactly with the 'standard'
#' implementations, due to differences in roundoff.
#'
#' These methods are reasonably fast, on par with the 'standard' implementations.
#' However, they will usually be faster than calling the various standard implementations
#' more than once.
#'
#' @return a vector; the first elements are the kth, k-1th through 2nd standardized, centered moment,
#' then the mean, then the number of (non-nan) elements in the input.
#'
#' @note
#' the kurtosis is \emph{excess kurtosis}, with a 3 subtracted, and should be nearly zero
#' for Gaussian input.
#'
#' @examples
#' x <- rnorm(1e5)
#' sd3(x)[1] - sd(x)
#'   skew4(x)[4] - length(x)
#'   skew4(x)[3] - mean(x)
#'   skew4(x)[2] - sd(x)
#' if (require(moments)) {
#'   skew4(x)[1] - skewness(x)
#' }
#' # check 'robustness'; only the mean should change:
#' kurt5(x + 1e12) - kurt5(x)
#' # check speed
#' if (require(microbenchmark) && require(moments)) {
#'   dumbk <- function(x) { c(kurtosis(x) - 3.0,skewness(x),sd(x),mean(x),length(x)) }
#'   set.seed(1234)
#'   x <- rnorm(1e6)
#'   print(kurt5(x) - dumbk(x))
#'   microbenchmark(dumbk(x),kurt5(x),times=10L)
#' }
#'
#' @template etc
#' @template ref-romo
#' @rdname firstmoments
#' @seealso runningmoments
#' @export
sd3 <- function(v, na_rm = FALSE) {
    .Call('fromo_sd3', PACKAGE = 'fromo', v, na_rm)
}

#' @rdname firstmoments
#' @export
skew4 <- function(v, na_rm = FALSE) {
    .Call('fromo_skew4', PACKAGE = 'fromo', v, na_rm)
}

#' @rdname firstmoments
#' @export
kurt5 <- function(v, na_rm = FALSE) {
    .Call('fromo_kurt5', PACKAGE = 'fromo', v, na_rm)
}

#' @rdname firstmoments
#' @export
cent_moments <- function(v, max_order = 5L, used_df = 1L, na_rm = FALSE) {
    .Call('fromo_cent_moments', PACKAGE = 'fromo', v, max_order, used_df, na_rm)
}

#' @title
#' Compute first K moments over a sliding window
#' @description
#' Compute the (standardized) 2nd through kth moments, the mean, and the number of elements over
#' an infinite or finite sliding window, returning a matrix.
#' 
#' @param v a vector
#' @param winsize the window size. if NA, equivalent to infinity.
#' @param recoper the recompute period. because subtraction of elements can cause
#' loss of precision, the computation of moments is restarted periodically based on 
#' this parameter. Larger values mean fewer restarts and faster, though less accurate
#' results. Note that the code checks for negative second and fourth moments and
#' recomputes when needed.
#' @param na_rm whether to remove NA, false by default.
#' @param lookahead for some of the operations, the value is compared to 
#' mean and standard deviation possibly using 'future' or 'past' information
#' by means of a non-zero lookahead. Positive values mean data are taken from
#' the future.
#'
#' @details
#'
#' Computes the number of elements, the mean, and the 2nd through kth
#' centered standardized moment, for \eqn{k=2,3,4}{k=2,3,4}. These
#' are computed via the numerically robust one-pass method of Bennett \emph{et. al.}
#' In general they will \emph{not} match exactly with the 'standard'
#' implementations, due to differences in roundoff.
#'
#' These methods are reasonably fast, on par with the 'standard' implementations.
#' However, they will usually be faster than calling the various standard implementations
#' more than once.
#'
#' @return a matrix; the first columns are the kth, k-1th through 2nd standardized, centered moment,
#' then a column of the mean, then a column of the number of (non-nan) elements in the input.
#' When there are not sufficient (non-nan) elements for the computation, NaN are returned.
#'
#' @note
#' the kurtosis is \emph{excess kurtosis}, with a 3 subtracted, and should be nearly zero
#' for Gaussian input.
#'
#' @examples
#' x <- rnorm(1e5)
#' run_sd3(x,10)
#' run_skew4(x,10)
#' run_kurt5(x,500)
#'
#' @template etc
#' @template ref-romo
#' @seealso firstmoments
#' @rdname runningmoments
#' @export
run_sd3 <- function(v, winsize = NA_integer_, recoper = 100L, na_rm = FALSE) {
    .Call('fromo_run_sd3', PACKAGE = 'fromo', v, winsize, recoper, na_rm)
}

#' @rdname runningmoments
#' @export
run_skew4 <- function(v, winsize = NA_integer_, recoper = 100L, na_rm = FALSE) {
    .Call('fromo_run_skew4', PACKAGE = 'fromo', v, winsize, recoper, na_rm)
}

#' @rdname runningmoments
#' @export
run_kurt5 <- function(v, winsize = NA_integer_, recoper = 100L, na_rm = FALSE) {
    .Call('fromo_run_kurt5', PACKAGE = 'fromo', v, winsize, recoper, na_rm)
}

#' @rdname runningmoments
#' @export
run_centered <- function(v, winsize = NA_integer_, recoper = 1000L, lookahead = 0L, na_rm = FALSE) {
    .Call('fromo_run_centered', PACKAGE = 'fromo', v, winsize, recoper, lookahead, na_rm)
}

#' @rdname runningmoments
#' @export
run_scaled <- function(v, winsize = NA_integer_, recoper = 100L, lookahead = 0L, na_rm = FALSE) {
    .Call('fromo_run_scaled', PACKAGE = 'fromo', v, winsize, recoper, lookahead, na_rm)
}

#' @rdname runningmoments
#' @export
run_zscored <- function(v, winsize = NA_integer_, recoper = 100L, lookahead = 0L, na_rm = FALSE) {
    .Call('fromo_run_zscored', PACKAGE = 'fromo', v, winsize, recoper, lookahead, na_rm)
}

#' @rdname runningmoments
#' @export
run_tscored <- function(v, winsize = NA_integer_, recoper = 100L, na_rm = FALSE) {
    .Call('fromo_run_tscored', PACKAGE = 'fromo', v, winsize, recoper, na_rm)
}

