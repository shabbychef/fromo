# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title
#' Compute first K moments
#' @description
#' Compute the (standardized) 2nd through kth moments, the mean, and the number of elements.
#' 
#' @param v a vector
#' @param na_rm whether to remove NA, false by default.
#' @param used_df the number of degrees of freedom consumed, used in the denominator
#' of the centered moments computation. These are subtracted from the number of
#' observations.
#' @param max_order the maximum order of the centered moment to be computed.
#'
#' @details
#'
#' Computes the number of elements, the mean, and the 2nd through kth
#' centered standardized moment, for \eqn{k=2,3,4}{k=2,3,4}. These
#' are computed via the numerically robust one-pass method of Bennett \emph{et. al.}
#' In general they will \emph{not} match exactly with the 'standard'
#' implementations, due to differences in roundoff.
#'
#' These methods are reasonably fast, on par with the 'standard' implementations.
#' However, they will usually be faster than calling the various standard implementations
#' more than once.
#'
#' @return a vector; the first elements are the kth, k-1th through 2nd standardized, centered moment,
#' then the mean, then the number of (non-nan) elements in the input.
#'
#' @note
#' the kurtosis is \emph{excess kurtosis}, with a 3 subtracted, and should be nearly zero
#' for Gaussian input.
#'
#' @examples
#' x <- rnorm(1e5)
#' sd3(x)[1] - sd(x)
#' skew4(x)[4] - length(x)
#' skew4(x)[3] - mean(x)
#' skew4(x)[2] - sd(x)
#' if (require(moments)) {
#'   skew4(x)[1] - skewness(x)
#' }
#' # check 'robustness'; only the mean should change:
#' kurt5(x + 1e12) - kurt5(x)
#' # check speed
#' if (require(microbenchmark) && require(moments)) {
#'   dumbk <- function(x) { c(kurtosis(x) - 3.0,skewness(x),sd(x),mean(x),length(x)) }
#'   set.seed(1234)
#'   x <- rnorm(1e6)
#'   print(kurt5(x) - dumbk(x))
#'   microbenchmark(dumbk(x),kurt5(x),times=10L)
#' }
#'
#' @template etc
#' @template ref-romo
#' @rdname firstmoments
#' @export
sd3 <- function(v, na_rm = FALSE) {
    .Call('fromo_sd3', PACKAGE = 'fromo', v, na_rm)
}

#' @rdname firstmoments
#' @export
skew4 <- function(v, na_rm = FALSE) {
    .Call('fromo_skew4', PACKAGE = 'fromo', v, na_rm)
}

#' @rdname firstmoments
#' @export
kurt5 <- function(v, na_rm = FALSE) {
    .Call('fromo_kurt5', PACKAGE = 'fromo', v, na_rm)
}

#' @rdname firstmoments
#' @export
cent_moments <- function(v, max_order = 5L, used_df = 0L, na_rm = FALSE) {
    .Call('fromo_cent_moments', PACKAGE = 'fromo', v, max_order, used_df, na_rm)
}

#' @title
#' Join or unjoin moments computations.
#'
#' @description
#'
#' Join or unjoin moments computations.
#'
#' @param ret1 an \eqn{ord+1} vector as output by \code{\link{cent_moments}}? consisting of
#' the count, the mean, then the k through ordth centered sum of some observations.
#' @param ret2 an \eqn{ord+1} vector as output by \code{\link{cent_moments}}? consisting of
#' the count, the mean, then the k through ordth centered sum of some observations.
#' @param ret3 an \eqn{ord+1} vector as output by \code{\link{cent_moments}}? consisting of
#' the count, the mean, then the k through ordth centered sum of some observations.
#'
#'
#' @return a vector the same size as the input consisting of the adjusted version of the input.
#' When there are not sufficient (non-nan) elements for the computation, \code{NaN} are returned.
#'
#' @examples
#'
#'  set.seed(1234)
#'  x1 <- rnorm(1e3,mean=1)
#'  x2 <- rnorm(1e3,mean=1)
#'  max_ord <- 6L
#'  rs1 <- cent_moments(x1,max_ord)
#'  rs2 <- cent_moments(x2,max_ord)
#'  rs3 <- cent_moments(c(x1,x2),max_ord)
#'  rs3alt <- join_moments(rs1,rs2)
#'  stopifnot(max(abs(rs3 - rs3alt)) < 1e-7)
#'  rs1alt <- unjoin_moments(rs3,rs2)
#'  rs2alt <- unjoin_moments(rs3,rs1)
#'  stopifnot(max(abs(rs1 - rs1alt)) < 1e-7)
#'  stopifnot(max(abs(rs2 - rs2alt)) < 1e-7)
#'
#' @template etc
#' @template ref-romo
#' @rdname joinmoments 
#' @export
join_moments <- function(ret1, ret2) {
    .Call('fromo_join_moments', PACKAGE = 'fromo', ret1, ret2)
}

#' @rdname joinmoments 
#' @export
unjoin_moments <- function(ret3, ret2) {
    .Call('fromo_unjoin_moments', PACKAGE = 'fromo', ret3, ret2)
}

#' @title
#' Compute first K moments over a sliding window
#' @description
#' Compute the (standardized) 2nd through kth moments, the mean, and the number of elements over
#' an infinite or finite sliding window, returning a matrix.
#' 
#' @param v a vector
#' @param window the window size. if given as finite integer or double, passed through.
#' If \code{NULL}, \code{NA_integer_}, \code{NA_real_} or \code{Inf} are given, equivalent
#' to an infinite window size. If negative, an error will be thrown.
#' @param recoper the recompute period. because subtraction of elements can cause
#' loss of precision, the computation of moments is restarted periodically based on 
#' this parameter. Larger values mean fewer restarts and faster, though less accurate
#' results. Note that the code checks for negative second and fourth moments and
#' recomputes when needed.
#' @param na_rm whether to remove NA, false by default.
#' @param max_order the maximum order of the centered moment to be computed.
#' @param min_df the minimum df to return a value, otherwise \code{NaN} is returned.
#' This can be used to prevent moments from being computed on too few observations.
#' Defaults to zero, meaning no restriction.
#' @param used_df the number of degrees of freedom consumed, used in the denominator
#' of the centered moments computation. These are subtracted from the number of
#' observations.
#'
#' @details
#'
#' Computes the number of elements, the mean, and the 2nd through kth
#' centered standardized moment, for \eqn{k=2,3,4}{k=2,3,4}. These
#' are computed via the numerically robust one-pass method of Bennett \emph{et. al.}
#'
#' Given the length \eqn{n} vector \eqn{x}, we output matrix \eqn{M} where
#' \eqn{M_{i,j}}{M_i,j} is the \eqn{order - j + 1} moment (\emph{i.e.}
#' excess kurtosis, skewness, standard deviation, mean or number of elements)
#' of \eqn{x_{i-window+1},x_{i-window+2},...,x_{i}}{x_(i-window+1),x_(i-window+2),...,x_i}.
#' Barring \code{NA} or \code{NaN}, this is over a window of size \code{window}.
#' During the 'burn-in' phase, we take fewer elements.
#'
#' @return a matrix; the first columns are the kth, k-1th through 2nd standardized, centered moment,
#' then a column of the mean, then a column of the number of (non-nan) elements in the input.
#' When there are not sufficient (non-nan) elements for the computation, \code{NaN} are returned.
#'
#' @note
#' the kurtosis is \emph{excess kurtosis}, with a 3 subtracted, and should be nearly zero
#' for Gaussian input.
#'
#' @examples
#' x <- rnorm(1e5)
#' xs3 <- running_sd3(x,10)
#' xs4 <- running_skew4(x,10)
#'
#' if (require(moments)) {
#'     set.seed(123)
#'     x <- rnorm(5e1)
#'     window <- 10L
#'     kt5 <- running_kurt5(x,window=window)
#'     rm1 <- t(sapply(seq_len(length(x)),function(iii) { 
#'                 xrang <- x[max(1,iii-window+1):iii]
#'                 c(moments::kurtosis(xrang)-3.0,moments::skewness(xrang),
#'                 sd(xrang),mean(xrang),length(xrang)) },
#'              simplify=TRUE))
#'     stopifnot(max(abs(kt5 - rm1),na.rm=TRUE) < 1e-12)
#' }
#'
#' xc6 <- running_cent_moments(x,window=100L,max_order=6L)
#'
#' @template etc
#' @template ref-romo
#' @rdname runningmoments
#' @export
running_sd3 <- function(v, window = NULL, na_rm = FALSE, min_df = 0L, recoper = 100L) {
    .Call('fromo_running_sd3', PACKAGE = 'fromo', v, window, na_rm, min_df, recoper)
}

#' @rdname runningmoments
#' @export
running_skew4 <- function(v, window = NULL, na_rm = FALSE, min_df = 0L, recoper = 100L) {
    .Call('fromo_running_skew4', PACKAGE = 'fromo', v, window, na_rm, min_df, recoper)
}

#' @rdname runningmoments
#' @export
running_kurt5 <- function(v, window = NULL, na_rm = FALSE, min_df = 0L, recoper = 100L) {
    .Call('fromo_running_kurt5', PACKAGE = 'fromo', v, window, na_rm, min_df, recoper)
}

#' @rdname runningmoments
#' @export
running_cent_moments <- function(v, window = NULL, max_order = 5L, na_rm = FALSE, min_df = 0L, used_df = 0L, recoper = 100L) {
    .Call('fromo_running_cent_moments', PACKAGE = 'fromo', v, window, max_order, na_rm, min_df, used_df, recoper)
}

#' @title
#' Compare data to moments computed over a sliding window.
#' @description
#' Computes moments over a sliding window, then adjusts the data accordingly, centering, or scaling,
#' or z-scoring, and so on.
#' 
#' @inheritParams running_cent_moments
#' @param min_df the minimum df to return a value, otherwise \code{NaN} is returned.
#' This can be used to prevent \emph{e.g.} Z-scores from being computed on only 3
#' observations. Defaults to zero, meaning no restriction, which can result in 
#' infinite Z-scores during the burn-in period.
#' @param lookahead for some of the operations, the value is compared to 
#' mean and standard deviation possibly using 'future' or 'past' information
#' by means of a non-zero lookahead. Positive values mean data are taken from
#' the future.
#'
#' @details
#'
#' Given the length \eqn{n} vector \eqn{x}, for
#' a given index \eqn{i}, define \eqn{x^{(i)}}{x^(i)}
#' as the vector of 
#' \eqn{x_{i-window+1},x_{i-window+2},...,x_{i}}{x_(i-window+1),x_(i-window+2),...,x_i},
#' where we do not run over the 'edge' of the vector. In code, this is essentially
#' \code{x[(max(1,i-window+1)):i]}. Then define \eqn{\mu_i}{mu_i}, \eqn{\sigma_i}{sigma_i}
#' and \eqn{n_i}{n_i} as, respectively, the sample mean, standard deviation and number of
#' non-NA elements in \eqn{x^{(i)}}{x^(i)}. 
#'
#' We compute output vector \eqn{m} the same size as \eqn{x}. 
#' For the 'centered' version of \eqn{x}, we have \eqn{m_i = x_i - \mu_i}{m_i = x_i - mu_i}.
#' For the 'scaled' version of \eqn{x}, we have \eqn{m_i = x_i / \sigma_i}{m_i = x_i / sigma_i}.
#' For the 'z-scored' version of \eqn{x}, we have \eqn{m_i = (x_i - \mu_i) / \sigma_i}{m_i = (x_i - mu_i) / sigma_i}.
#' For the 't-scored' version of \eqn{x}, we have \eqn{m_i = \sqrt{n_i} \mu_i / \sigma_i}{m_i = sqrt(n_i) mu_i / sigma_i}.
#'
#' We also allow a 'lookahead' for some of these operations.
#' If positive, the moments are computed using data from larger indices;
#' if negative, from smaller indices. Letting \eqn{j = i + lookahead}{j = i + lookahead}:
#' For the 'centered' version of \eqn{x}, we have \eqn{m_i = x_i - \mu_j}{m_i = x_i - mu_j}.
#' For the 'scaled' version of \eqn{x}, we have \eqn{m_i = x_i / \sigma_j}{m_i = x_i / sigma_j}.
#' For the 'z-scored' version of \eqn{x}, we have \eqn{m_i = (x_i - \mu_j) / \sigma_j}{m_i = (x_i - mu_j) / sigma_j}.
#'
#' @return a vector the same size as the input consisting of the adjusted version of the input.
#' When there are not sufficient (non-nan) elements for the computation, \code{NaN} are returned.
#'
#' @examples
#'
#' if (require(moments)) {
#'     set.seed(123)
#'     x <- rnorm(5e1)
#'     window <- 10L
#'     rm1 <- t(sapply(seq_len(length(x)),function(iii) { 
#'                   xrang <- x[max(1,iii-window+1):iii]
#'                   c(sd(xrang),mean(xrang),length(xrang)) },
#'                   simplify=TRUE))
#'     rcent <- running_centered(x,window=window)
#'     rscal <- running_scaled(x,window=window)
#'     rzsco <- running_zscored(x,window=window)
#'     rshrp <- running_sharpe(x,window=window)
#'     rtsco <- running_tstat(x,window=window)
#'     stopifnot(max(abs(rcent - (x - rm1[,2])),na.rm=TRUE) < 1e-12)
#'     stopifnot(max(abs(rscal - (x / rm1[,1])),na.rm=TRUE) < 1e-12)
#'     stopifnot(max(abs(rzsco - ((x - rm1[,2]) / rm1[,1])),na.rm=TRUE) < 1e-12)
#'     stopifnot(max(abs(rshrp - (rm1[,2] / rm1[,1])),na.rm=TRUE) < 1e-12)
#'     stopifnot(max(abs(rtsco - ((sqrt(rm1[,3]) * rm1[,2]) / rm1[,1])),na.rm=TRUE) < 1e-12)
#' }
#'
#' @seealso \code{\link{scale}}
#' @template etc
#' @template ref-romo
#' @rdname runningadjustments
#' @export
running_centered <- function(v, window = NULL, na_rm = FALSE, min_df = 0L, lookahead = 0L, recoper = 100L) {
    .Call('fromo_running_centered', PACKAGE = 'fromo', v, window, na_rm, min_df, lookahead, recoper)
}

#' @rdname runningadjustments
#' @export
running_scaled <- function(v, window = NULL, na_rm = FALSE, min_df = 0L, lookahead = 0L, recoper = 100L) {
    .Call('fromo_running_scaled', PACKAGE = 'fromo', v, window, na_rm, min_df, lookahead, recoper)
}

#' @rdname runningadjustments
#' @export
running_zscored <- function(v, window = NULL, na_rm = FALSE, min_df = 0L, lookahead = 0L, recoper = 100L) {
    .Call('fromo_running_zscored', PACKAGE = 'fromo', v, window, na_rm, min_df, lookahead, recoper)
}

#' @rdname runningadjustments
#' @export
running_sharpe <- function(v, window = NULL, na_rm = FALSE, min_df = 0L, recoper = 100L) {
    .Call('fromo_running_sharpe', PACKAGE = 'fromo', v, window, na_rm, min_df, recoper)
}

#' @rdname runningadjustments
#' @export
running_tstat <- function(v, window = NULL, na_rm = FALSE, min_df = 0L, recoper = 100L) {
    .Call('fromo_running_tstat', PACKAGE = 'fromo', v, window, na_rm, min_df, recoper)
}

